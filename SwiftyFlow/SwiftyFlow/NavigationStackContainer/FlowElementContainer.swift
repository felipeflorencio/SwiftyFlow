//
//  FlowElementContainer.swift
//  SwiftyFlow
//
//  Created by Felipe Florencio Garcia on 09/05/2019.
//  Copyright Â© 2019 Felipe Florencio Garcia. All rights reserved.
//

import UIKit

// The idea of have FlowElementContainer is a way of have the reference
// encapsulated inside a object that we can manage the referenceto our
// real object, as we will be using this inside an array, we need to be
// able to destroy easily our array without have the risk of some view
// controller hold the reference to the object
class FlowElementContainer<T> where T: UIViewController {
    
    public enum Scope {
        case none       // fresh instance all the time, default
        case weak       // weak ref to instance, at leas one object
        case strong     // keep alive - you need to know what you are doing
    }
    
    typealias Container = () -> T?
    private var factory: (Container)?
    private(set) var scope: Scope = .weak
    private(set) var forType: T.Type
    private weak var weakInstance: AnyObject?
    private var strongInstance: T?
    
    init(for type: T.Type, resolving: @escaping Container) {
        factory = resolving
        forType = type
    }
    
    deinit {
        factory = nil
        weakInstance = nil
        strongInstance = nil
    }
    
    func resolve<T>() -> T? {
        switch scope {
        case .none:
            return factory?() as? T
        case .weak:
            let resolved = (weakInstance as? T) ?? (factory?() as? T)
            weakInstance = resolved as? UIViewController
            return resolved
        case .strong where strongInstance == nil:
            strongInstance = factory?()
            fallthrough
        case .strong:
            return strongInstance as? T
        }
    }
    
    // Set the scope that we will want for this object
    @discardableResult
    public func inScope(scope: Scope) -> Self {
        self.scope = scope
        return self
    }
    
    // MARK: Helper to update self object reference for now when load from storyboard
    // for this we will nullify factory as we should not get anymore from the closure
    // and not maintain the reference as this were generated by the Navigation Coordinator
    func updateInstance<T: UIViewController>(reference object: T) {
        // TODO: (felipe) Validate if this behaviour is ok or need to be changed
        self.strongInstance = nil
        
        self.weakInstance = object
    }
    
    // This is used to remove any object reference and make sure that if we start the flow again
    // we will always use the fresh instance as is suppose to be
    func resetInstanceReference() {
        debugPrint("Destroying reference instance for \(self.forType)")
        self.weakInstance = nil
        self.strongInstance = nil
    }
}
