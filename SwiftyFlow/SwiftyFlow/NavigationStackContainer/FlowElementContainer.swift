//
//  FlowElementContainer.swift
//  SwiftyFlow
//
//  Created by Felipe Florencio Garcia on 09/05/2019.
//  Copyright Â© 2019 Felipe Florencio Garcia. All rights reserved.
//

import UIKit

internal typealias CallbackFunctionType = Any

// The idea of have FlowElementContainer is a way of have the reference
// encapsulated inside a object that we can manage the referenceto our
// real object, as we will be using this inside an array, we need to be
// able to destroy easily our array without have the risk of some view
// controller hold the reference to the object
class FlowElementContainer<T> {
    
    public enum Scope {
        case none       // fresh instance all the time, default
        case weak       // weak ref to instance, at leas one object
        case strong     // keep alive - you need to know what you are doing
    }
    
    typealias Container = () -> T?
    private var factory: (Container)?
    
    private(set) var factoryParameter: CallbackFunctionType?
    
    private(set) var scope: Scope = .none
    private(set) var forType: T.Type
    private weak var weakInstance: AnyObject?
    private var strongInstance: T?
    private(set) var arguments: Any?
    
    init(for type: T.Type, resolving: @escaping Container) {
        factory = resolving
        forType = type
    }
    
    init(for type: T.Type, with arg: Any, resolving: CallbackFunctionType) {
        factoryParameter = resolving
        forType = type
        arguments = arg
    }
    
    deinit {
        factory = nil
        weakInstance = nil
        strongInstance = nil
    }
    
    func resolve<T>() -> T? {
        switch scope {
        case .none:
            return factory?() as? T
        case .weak:
            // This is a check for security reason, mainly when you call to resolve from storyboard
            // as storyboard resolve the class everytime so we do need to use weak reference, as when
            // call again we will use the one from storyboard, so will recreate the view and the instance
            // class that is attached to that view, when update we want to make sure strong it's nil
            if strongInstance != nil {
                strongInstance = nil
            }
            
            let resolved = (weakInstance as? T) ?? (factory?() as? T)
            weakInstance = resolved as? UIViewController
            return resolved
        case .strong where strongInstance == nil:
            strongInstance = factory?()
            fallthrough
        case .strong:
            return strongInstance as? T
        }
    }
    
    // Set the scope that we will want for this object
    @discardableResult
    public func inScope(scope: Scope) -> Self {
        self.scope = scope
        return self
    }
    
    // MARK: Helper to update self object reference for now when load from storyboard
    // for this we will nullify factory as we should not get anymore from the closure
    // and not maintain the reference as this were generated by the Navigation Coordinator
    func updateInstance<T: UIViewController>(reference object: T) {
        // TODO: (felipe) Validate if this behaviour is ok or need to be changed
        self.strongInstance = nil
        
        self.weakInstance = object
    }
    
    // This is used to remove any object reference and make sure that if we start the flow again
    // we will always use the fresh instance as is suppose to be
    func resetWeakInstanceReference() {
        debugPrint("Destroying weak reference instance for: \(self.forType)")
        self.weakInstance = nil
    }
    
    func resetInstanceReference() {
        debugPrint("Destroying strong and weak reference instance for: \(self.forType)")
        self.strongInstance = nil
        self.weakInstance = nil
    }
}
